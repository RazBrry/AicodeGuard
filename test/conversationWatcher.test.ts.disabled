import { expect } from 'chai';
import * as sinon from 'sinon';
import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';
import { ConversationWatcher } from '../src/watchers/ConversationWatcher';

describe('ConversationWatcher', () => {
  let watcher: ConversationWatcher;
  let existsSyncStub: sinon.SinonStub;
  let readdirSyncStub: sinon.SinonStub;
  let readFileSyncStub: sinon.SinonStub;
  let watchStub: sinon.SinonStub;
  let homeDirStub: sinon.SinonStub;

  beforeEach(() => {
    // Mock os.homedir
    homeDirStub = sinon.stub(os, 'homedir').returns('/mock/home');
    
    // Mock fs methods
    existsSyncStub = sinon.stub(fs, 'existsSync');
    readdirSyncStub = sinon.stub(fs, 'readdirSync');
    readFileSyncStub = sinon.stub(fs, 'readFileSync');
    watchStub = sinon.stub(fs, 'watch');

    // Setup default mock behavior
    existsSyncStub.withArgs('/mock/home/Projects').returns(true);
    readdirSyncStub.withArgs('/mock/home/Projects').returns(['project1', 'project2']);
    existsSyncStub.withArgs('/mock/home/Projects/project1/TODO.claude.md').returns(true);
    existsSyncStub.withArgs('/mock/home/Projects/project2/TODO.claude.md').returns(false);

    // Mock fs.watch to return a simple mock watcher
    const mockWatcher = {
      close: sinon.stub(),
      on: sinon.stub(),
      addListener: sinon.stub(),
      removeListener: sinon.stub(),
      removeAllListeners: sinon.stub(),
      emit: sinon.stub(),
      prependListener: sinon.stub(),
      prependOnceListener: sinon.stub(),
      once: sinon.stub(),
      off: sinon.stub(),
      ref: sinon.stub(),
      unref: sinon.stub()
    };
    watchStub.returns(mockWatcher);

    watcher = new ConversationWatcher();
  });

  afterEach(() => {
    homeDirStub.restore();
    existsSyncStub.restore();
    readdirSyncStub.restore(); 
    readFileSyncStub.restore();
    watchStub.restore();
    watcher?.dispose();
  });

  it('should initialize without errors', () => {
    expect(watcher).to.be.instanceOf(ConversationWatcher);
  });

  it('should start watching when Projects directory exists', async () => {
    await watcher.startWatching();
    
    // Should check if Projects directory exists
    expect(existsSyncStub.calledWith('/mock/home/Projects')).to.be.true;
    
    // Should read directory contents
    expect(readdirSyncStub.calledWith('/mock/home/Projects')).to.be.true;
  });

  it('should handle non-existent Projects directory', async () => {
    existsSyncStub.withArgs('/mock/home/Projects').returns(false);
    
    await watcher.startWatching();
    
    expect(readdirSyncStub.called).to.be.false;
  });

  it('should watch TODO.claude.md files that exist', async () => {
    await watcher.startWatching();
    
    // Should check for TODO.claude.md in project1 (exists)
    expect(existsSyncStub.calledWith('/mock/home/Projects/project1/TODO.claude.md')).to.be.true;
    
    // Should check for TODO.claude.md in project2 (doesn't exist)
    expect(existsSyncStub.calledWith('/mock/home/Projects/project2/TODO.claude.md')).to.be.true;
    
    // Should only watch the file that exists
    expect(watchStub.calledOnce).to.be.true;
    expect(watchStub.calledWith('/mock/home/Projects/project1/TODO.claude.md')).to.be.true;
  });

  it('should return correct stats', () => {
    const stats = watcher.getStats();
    
    expect(stats).to.have.property('watchedFiles');
    expect(stats).to.have.property('trackedFiles');
    expect(stats).to.have.property('interventionActive');
    expect(stats).to.have.property('lastInterventionTime');
    
    expect(stats.interventionActive).to.be.false;
  });

  it('should dispose properly', () => {
    watcher.dispose();
    
    // Should clean up internal state
    const stats = watcher.getStats();
    expect(stats.watchedFiles).to.equal(0);
    expect(stats.trackedFiles).to.equal(0);
  });
});