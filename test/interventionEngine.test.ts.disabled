import { expect } from 'chai';
import * as sinon from 'sinon';
import { InterventionEngine } from '../src/analyzers/InterventionEngine';
import { FileAnalysis } from '../src/types/common';
import * as vscode from 'vscode';

// Mock VS Code output channel
const mockOutputChannel = {
  appendLine: sinon.stub(),
  show: sinon.stub(),
  dispose: sinon.stub()
} as unknown as vscode.OutputChannel;

describe('InterventionEngine', () => {
  let interventionEngine: InterventionEngine;
  let sandbox: sinon.SinonSandbox;

  beforeEach(() => {
    sandbox = sinon.createSandbox();
    interventionEngine = new InterventionEngine(mockOutputChannel);
  });

  afterEach(() => {
    sandbox.restore();
  });

  it('should initialize correctly', () => {
    expect(interventionEngine).to.be.instanceOf(InterventionEngine);
  });

  it('should not trigger intervention when AI intervention is active', () => {
    const analysis: FileAnalysis = {
      filePath: '/test/file.ts',
      timestamp: Date.now(),
      detectionResult: {
        patterns: [{ 
          category: 'SECURITY_ISSUES', 
          pattern: 'eval', 
          match: 'eval("test")', 
          weight: 25, 
          source: 'code' 
        }],
        severityScore: 25,
        qualityLevel: 'CRITICAL',
        hasDirectRefusal: false,
        hasEducationalDeflection: false,
        terminalPatterns: [],
        codePatterns: []
      },
      triggerType: 'MANUAL',
      interventionLevel: 'NONE'
    };

    // First call should return true (no active intervention)
    expect(interventionEngine.shouldTriggerAIIntervention(analysis)).to.be.true;
    
    // After triggering intervention, should return false
    // Note: This is testing the logic, actual AI intervention would be async
  });

  it('should not trigger intervention without active terminal', () => {
    // Mock vscode.window to have no active terminal
    const windowStub = sandbox.stub(vscode.window, 'activeTerminal').value(undefined);
    
    const analysis: FileAnalysis = {
      filePath: '/test/file.ts',
      timestamp: Date.now(),
      detectionResult: {
        patterns: [],
        severityScore: 50,
        qualityLevel: 'CRITICAL',
        hasDirectRefusal: false,
        hasEducationalDeflection: false,
        terminalPatterns: [],
        codePatterns: []
      },
      triggerType: 'MANUAL',
      interventionLevel: 'NONE'
    };

    expect(interventionEngine.shouldTriggerAIIntervention(analysis)).to.be.false;
  });

  it('should trigger intervention for CRITICAL quality level', () => {
    // Mock active terminal
    const mockTerminal = { sendText: sinon.stub(), show: sinon.stub() };
    sandbox.stub(vscode.window, 'activeTerminal').value(mockTerminal);
    
    const analysis: FileAnalysis = {
      filePath: '/test/file.ts',
      timestamp: Date.now(),
      detectionResult: {
        patterns: [],
        severityScore: 50,
        qualityLevel: 'CRITICAL',
        hasDirectRefusal: false,
        hasEducationalDeflection: false,
        terminalPatterns: [],
        codePatterns: []
      },
      triggerType: 'MANUAL',
      interventionLevel: 'NONE'
    };

    expect(interventionEngine.shouldTriggerAIIntervention(analysis)).to.be.true;
  });

  it('should not trigger intervention for non-CRITICAL quality levels', () => {
    // Mock active terminal
    const mockTerminal = { sendText: sinon.stub(), show: sinon.stub() };
    sandbox.stub(vscode.window, 'activeTerminal').value(mockTerminal);
    
    const analysis: FileAnalysis = {
      filePath: '/test/file.ts',
      timestamp: Date.now(),
      detectionResult: {
        patterns: [],
        severityScore: 20,
        qualityLevel: 'ACCEPTABLE',
        hasDirectRefusal: false,
        hasEducationalDeflection: false,
        terminalPatterns: [],
        codePatterns: []
      },
      triggerType: 'MANUAL',
      interventionLevel: 'NONE'
    };

    expect(interventionEngine.shouldTriggerAIIntervention(analysis)).to.be.false;
  });
});