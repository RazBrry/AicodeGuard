import { expect } from 'chai';
import * as sinon from 'sinon';
import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';
import * as vscode from 'vscode';
import { ConversationWatcher } from '../src/watchers/ConversationWatcher';
import { ConversationAnalyzer } from '../src/analyzers/ConversationAnalyzer';
import { NotificationManager } from '../src/managers/NotificationManager';

// Mock VS Code APIs
const mockOutputChannel = {
  appendLine: (msg: string) => { /* console.log(msg); */ },
  show: () => {},
  dispose: () => {},
} as vscode.OutputChannel;

const mockWindow = {
  showWarningMessage: async (message: string, ...items: string[]) => items[0],
} as typeof vscode.window;

// Mock fs.watch
class MockFSWatcher extends fs.FSWatcher {
  private _listeners: { [event: string]: Function[] } = {};

  constructor() {
    super();
  }

  on(event: string, listener: Function): this {
    if (!this._listeners[event]) {
      this._listeners[event] = [];
    }
    this._listeners[event].push(listener);
    return this;
  }

  trigger(event: string, ...args: any[]): void {
    if (this._listeners[event]) {
      this._listeners[event].forEach(listener => listener(...args));
    }
  }

  close(): void {
    // Mock close
  }
}

describe('ConversationWatcher', () => {
  let watcher: ConversationWatcher;
  let sandbox: sinon.SinonSandbox;
  let mockFsWatch: sinon.SinonStub;
  let mockReadFileSync: sinon.SinonStub;
  let mockExistsSync: sinon.SinonStub;
  let mockReaddirSync: sinon.SinonStub;
  let mockNotificationManager: sinon.SinonStubbedInstance<NotificationManager>;
  let mockConversationAnalyzer: sinon.SinonStubbedInstance<ConversationAnalyzer>;

  beforeEach(() => {
    sandbox = sinon.createSandbox();

    // Mock fs methods
    mockFsWatch = sandbox.stub(fs, 'watch').returns(new MockFSWatcher() as fs.FSWatcher);
    mockReadFileSync = sandbox.stub(fs, 'readFileSync');
    mockExistsSync = sandbox.stub(fs, 'existsSync');
    mockReaddirSync = sandbox.stub(fs, 'readdirSync');

    // Mock NotificationManager
    mockNotificationManager = sandbox.stub(NotificationManager.getInstance());
    sandbox.stub(NotificationManager, 'getInstance').returns(mockNotificationManager);

    // Mock ConversationAnalyzer
    mockConversationAnalyzer = sandbox.stub(ConversationAnalyzer.prototype);
    sandbox.stub(ConversationAnalyzer.prototype, 'analyzeTodoBailoutPatterns').returns({
      severity: 'HIGH',
      bailoutPatterns: ['test pattern'],
      score: 30,
    });
    sandbox.stub(ConversationAnalyzer.prototype, 'shouldTriggerIntervention').returns(true);

    // Mock vscode.window
    Object.defineProperty(vscode, 'window', {
      value: mockWindow,
      writable: true,
    });

    // Mock os.homedir
    sandbox.stub(os, 'homedir').returns('/mock/home');

    watcher = new ConversationWatcher();
  });

  afterEach(() => {
    sandbox.restore();
  });

  it('should not start watching if projects directory does not exist', async () => {
    mockExistsSync.withArgs('/mock/home/Projects').returns(false);
    await watcher.startWatching();
    expect(mockReaddirSync.called).to.be.false;
  });

  it('should find and watch existing TODO.claude.md files', async () => {
    mockExistsSync.withArgs('/mock/home/Projects').returns(true);
    mockReaddirSync.returns(['project1', 'project2']);
    mockExistsSync.withArgs('/mock/home/Projects/project1/TODO.claude.md').returns(true);
    mockExistsSync.withArgs('/mock/home/Projects/project2/TODO.claude.md').returns(false);

    await watcher.startWatching();
    expect(mockFsWatch.calledOnceWith('/mock/home/Projects/project1/TODO.claude.md')).to.be.true;
  });

  it('should schedule analysis on file change', async () => {
    mockExistsSync.withArgs('/mock/home/Projects').returns(true);
    mockReaddirSync.returns(['project1']);
    mockExistsSync.withArgs('/mock/home/Projects/project1/TODO.claude.md').returns(true);
    mockReadFileSync.returns('initial content');

    const clock = sinon.useFakeTimers();
    await watcher.startWatching();

    const mockWatcher = mockFsWatch.firstCall.returnValue as MockFSWatcher;
    mockWatcher.trigger('change');

    // Advance time to trigger analysis
    clock.tick(2000);

    expect(mockReadFileSync.calledTwice).to.be.true; // Initial read + read after change
    expect(mockConversationAnalyzer.analyzeTodoBailoutPatterns.calledOnce).to.be.true;
    clock.restore();
  });

  it('should trigger intervention if analysis is HIGH and can intervene', async () => {
    mockExistsSync.withArgs('/mock/home/Projects').returns(true);
    mockReaddirSync.returns(['project1']);
    mockExistsSync.withArgs('/mock/home/Projects/project1/TODO.claude.md').returns(true);
    mockReadFileSync.returns('new content with HIGH bailout');

    const clock = sinon.useFakeTimers();
    await watcher.startWatching();

    const mockWatcher = mockFsWatch.firstCall.returnValue as MockFSWatcher;
    mockWatcher.trigger('change');
    clock.tick(2000);

    expect(mockNotificationManager.queueNotification.calledOnce).to.be.true;
    expect(mockWindow.showWarningMessage.calledOnce).to.be.true;
    clock.restore();
  });

  it('should not trigger intervention if within cooldown period', async () => {
    mockExistsSync.withArgs('/mock/home/Projects').returns(true);
    mockReaddirSync.returns(['project1']);
    mockExistsSync.withArgs('/mock/home/Projects/project1/TODO.claude.md').returns(true);
    mockReadFileSync.returns('new content with HIGH bailout');

    const clock = sinon.useFakeTimers();
    await watcher.startWatching();

    const mockWatcher = mockFsWatch.firstCall.returnValue as MockFSWatcher;
    mockWatcher.trigger('change');
    clock.tick(2000); // First intervention

    mockWatcher.trigger('change');
    clock.tick(10000); // Within cooldown

    expect(mockNotificationManager.queueNotification.calledOnce).to.be.true; // Only one intervention
    clock.restore();
  });

  it('should extract messages correctly', () => {
    const content = `# Project
## Message 1
Some text.
### Sub-message
- Item 1
- Item 2
## Message 2
1. Step 1
2. Step 2
`;
    mockReadFileSync.returns(content);

    // Temporarily override the private method for testing
    const extractMessages = (watcher as any).extractMessages.bind(watcher);
    const messages = extractMessages(content);

    expect(messages).to.have.lengthOf(8); // Project, Message 1, Some text, Sub-message, Item 1, Item 2, Message 2, Step 1, Step 2
    expect(messages[0]).to.equal('# Project\n');
    expect(messages[1]).to.equal('Message 1\nSome text.\n');
  });

  it('should dispose all resources', async () => {
    mockExistsSync.withArgs('/mock/home/Projects').returns(true);
    mockReaddirSync.returns(['project1']);
    mockExistsSync.withArgs('/mock/home/Projects/project1/TODO.claude.md').returns(true);
    mockReadFileSync.returns('initial content');

    await watcher.startWatching();
    const mockWatcherInstance = mockFsWatch.firstCall.returnValue as MockFSWatcher;
    const closeSpy = sandbox.spy(mockWatcherInstance, 'close');

    watcher.dispose();
    expect(closeSpy.calledOnce).to.be.true;
  });
});
