import { expect } from 'chai';
import * as sinon from 'sinon';
import { ConfigManager, MonitoringMode, AggressivenessLevel } from '../src/managers/ConfigManager';
import * as vscode from 'vscode';

// Mock VS Code output channel
const mockOutputChannel = {
  appendLine: sinon.stub(),
  show: sinon.stub(),
  dispose: sinon.stub()
} as unknown as vscode.OutputChannel;

describe('ConfigManager', () => {
  let configManager: ConfigManager;
  let workspaceStub: sinon.SinonStub;
  let sandbox: sinon.SinonSandbox;

  beforeEach(() => {
    sandbox = sinon.createSandbox();
    
    // Mock vscode.workspace.getConfiguration
    const mockConfig = {
      get: sandbox.stub().callsFake((key: string, defaultValue: any) => {
        switch (key) {
          case 'monitoringMode': return 'both';
          case 'aggressivenessLevel': return 'sophisticated';
          case 'autoIntervention': return true;
          case 'typingDelay': return 2000;
          case 'interventionCooldown': return 30000;
          case 'blockCriticalSaves': return true;
          default: return defaultValue;
        }
      }),
      update: sandbox.stub().resolves(),
      has: sandbox.stub().returns(true),
      inspect: sandbox.stub().returns({})
    };
    
    workspaceStub = sandbox.stub(vscode.workspace, 'getConfiguration').returns(mockConfig);
    configManager = ConfigManager.getInstance(mockOutputChannel);
  });

  afterEach(() => {
    sandbox.restore();
  });

  it('should be a singleton', () => {
    const instance1 = ConfigManager.getInstance(mockOutputChannel);
    const instance2 = ConfigManager.getInstance(mockOutputChannel);
    expect(instance1).to.equal(instance2);
  });

  it('should load default configuration', () => {
    const config = configManager.getConfig();
    
    expect(config.monitoringMode).to.equal('both');
    expect(config.aggressivenessLevel).to.equal('sophisticated');
    expect(config.autoIntervention).to.be.true;
    expect(config.typingDelay).to.equal(2000);
    expect(config.interventionCooldown).to.equal(30000);
    expect(config.blockCriticalSaves).to.be.true;
  });

  it('should have predefined aggressiveness profiles', () => {
    const profile = configManager.getProfile('zero-tolerance');
    
    expect(profile).to.exist;
    expect(profile.name).to.equal('Zero Tolerance');
    expect(profile.thresholds.criticalScore).to.be.a('number');
  });

  it('should update monitoring mode', async () => {
    await configManager.setMonitoringMode('fileWatcher');
    
    const config = configManager.getConfig();
    expect(config.monitoringMode).to.equal('fileWatcher');
  });

  it('should update aggressiveness level', async () => {
    await configManager.setAggressivenessLevel('light');
    
    const config = configManager.getConfig();
    expect(config.aggressivenessLevel).to.equal('light');
  });

  it('should validate monitoring mode values', () => {
    const validModes: MonitoringMode[] = ['fileWatcher', 'terminal', 'both', 'disabled'];
    
    for (const mode of validModes) {
      expect(() => configManager.setMonitoringMode(mode)).to.not.throw;
    }
  });

  it('should validate aggressiveness level values', () => {
    const validLevels: AggressivenessLevel[] = ['zero-tolerance', 'sophisticated', 'light'];
    
    for (const level of validLevels) {
      expect(() => configManager.setAggressivenessLevel(level)).to.not.throw;
    }
  });
});